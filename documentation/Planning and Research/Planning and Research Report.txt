CI301 - The Individual ProjectPlanning and researcHThomas TaylorStudent Number: 08813043Supervisor: Graham WinstanleyProject Aims and ObjectivesThe primary objective of my project is to investigate the feasibility (and effectiveness) of incorporating academic machine learning techniques into computer games.I intend to do this by developing an AI system which is capable of controlling a number of agents to safely navigate a game environment. The agents should also be able to develop a knowledge-base dynamically based on observations made whilst navigating the environment and apply this in order to traverse the world. Problem DomainThe definition of ‘artificial intelligence’ can differ greatly depending on its application or indeed from researcher to researcher. According to John McCarthy, the computer scientist who first coined the term in the 1950’s, artificial intelligence is “the science and engineering of making intelligent machines”. An important aspect to creating an ‘intelligent machine’, is its ability to learn from experiences, and modify its behaviour accordingly when faced with similar scenarios in the future. This is a problem which has been given extensive research and various techniques have been developed to tackle a variety of learning problems. In fact, machine learning techniques are already used in a number of commercial applications to solve a number of computing problems such as speech recognition, robotic control and machine vision, proving that it can be a very useful solution to a variety of problems, especially problems which may have unexpected outcomes which could not be predicted by the application designer. Of the various techniques, those most applicable to computer games are Decision trees, neural networks, genetic algorithms and reinforcement learning. There has been substantial research into using machine learning in First-Person Shooter (FPS), Real-Time Strategy (RTS), and more traditional board games. Board games largely use complex search algorithms to look up possible moves in a large database, and rarely require any ‘learning’.Academic research into FPS/RTS, but none available commercially. NERO, NEAT, Retaliate, CBRetaliate.Despite this promising research, the AI systems used in even the most cutting-edge commercial games is far removed from that of academic AI research. Rather, the AI we see in computer games focuses on trying to fool the player into believing the system is more intelligent than it is, choosing to use ‘smoke and mirrors’ and cheap tricks rather than proven academic AI techniques. The reality is that games rarely venture beyond pathfinding algorithms when it comes to using academic AI, with their apparent ‘intelligence’ usually having been pre-scripted. In addition, many games are programmed to be intentionally unintelligent or even ‘stupid’ (as described in ‘Artificial Stupidity: The Art of Intentional Mistakes’ [Liden]) in order for the game not to be deemed too ‘challenging’. This often means that “a large part of the gameplay in many games [is] figuring out what the AI is programmed to do and learning to defeat it” [Miikkulainen - Creating Intelligent Agents in Games]. While using basic AI is often an intentional ‘design feature’ in games, historically AI processing has been given much lower priority than the 3D graphics for example, meaning that highly complex AI systems were just not computationally possible. However, in an age where computing power is advancing at a rapid pace [Moore’s law], and we are starting to see a plateau in the more processor intensive processes such as graphics, we are starting to see more focus and development into game AI. Indeed, in a generation where computer games are incredibly complex and engaging forms of entertainment with increasingly complex worlds, we need AI that can compliment this; gamers will no longer accept sub-par artificial intelligence.That being said, there are a few examples where AI has been used in commercial games quite effectively in less ‘out-of-the-box’ scenarios than merely creating highly efficient teamwork-capable enemies in shooting games. One of these is Lionhead Studios’ 2001 ‘god’ game Black & White. In it, the player is given a pet ‘Creature’ to do their bidding, which has the capacity to learn from the player’s actions, as well as the actions of the various computer-controlled characters in the game (including other Creatures). For example, the creature learns what objects are suitable to eat based on taste, and what it sees others eating. This can mean that the Creature learns to eat the player’s followers, which may require the player to punish the Creature for doing so. This learning is achieved with a combination of decision trees and neural networks, and uses a modified version of Quinlan’s ID3 algorithm to do so. SolutionAfter carrying out some initial research into the use of machine learning in computer games, I discovered that there had already been some fairly extensive research into using machine learning techniques in the FPS and RTS genres, including the development of machine learning engines capable of such. Partially for this reason, I made the decision to focus on a the use of machine learning in a puzzle game. For my project, I have chosen to create a game similar to the popular puzzle game Lemmings, and replace the human control element with my AI system. Originally released in 1991 for the PC and Commodore Amiga, Lemmings was a critical and commercial success. The game has a very simple premise: to guide a group of computer-controlled ‘lemmings‘ across a level from the entrance-point to the exit. The lemmings themselves, although computer controlled, have no AI to speak of, and merely walk in one direction until they reach an immovable object (such as a wall) or a trap (water, spikes, big drops etc.), the latter resulting in the demise of the lemming. Each level requires that a certain number of lemmings reach the exit in order for the player to progress.I felt that it would be an interesting challenge to see if I could design a system which was capable of guiding a group of AI characters across a 3D environment safely, My project can be separated into two distinct parts/deliverables: the game component, and the AI system controlling the agents’ behaviour.The Game ComponentThe game component of my project is essentially a stripped-down version of the game with limited tools given to the lemmings (if any at all), and a very limited number of levels. It should be able to work standalone (without the AI system) and would function similarly to the Lemmings game; the characters should enter the level and just walk continuously until they are killed, or reach an immovable object, after which they return the way they came.The game itself will consist of a simple 3D game environment viewed side-on so that it acts as a 2D platformer (in as much as there will only be movement along 2 planes). The environment will essentially be a number of platforms of varying heights and sizes.In addition to the environment, the game will need a variety of obstacles to hinder the progress of the lemmings. The obstacles that I plan to include in my game will likely be pits, spikes, large rocks, and some form of water/lava. The main goal with the type and number of obstacles in the game is to make sure that there is a suitable complexity/number of items for the system to have to process and have to reason about.I will obviously also need the lemming characters themselves, which will need some basic animation, as well as some very basic ‘AI’ to allow them to move across the level.The final thing needed for my game world will be the interface. Unlike the Lemmings game, I am choosing to remove most (if not, all) of the tools which are given to the player for the sake of simplicity. Instead, I intend to add some sort of interface to the game which will allow the player to tweak various parameters in the AI system. For example, the curiosity of the lemmings, or the level of reward given for certain tasks. This will basically act as a way to test the system in real-time without having to edit scripts or the code directly, and allow for easy user testing of my system.I will be using a game engine to take care of a lot of the game-related functionality such as model loading, lighting and physics.The AI SystemThe AI system itself will form the bulk of my work, and will operate behind the scenes of the game component to implement the machine learning techniques I intend to explore in this project. I intend to implement two ( or possibly more) alternative machine learning techniques. To begin with, I plan on implementing reinforcement learning and decision trees, as I feel that they are most applicable to the context of this project. However, time permitting, I would also like to implement either neural networks or genetic algorithms.In order for my project to be a success, my AI system needs to have certain basic functionality. To begin with, the system needs to be able to recognise when an agent has come into contact with any interactive objects, such as walls, spikes, large drops etc. My system then needs to be able to deduce what kind of object it is from its attributes and by querying its existing knowledge-base for any similar obstacles it may have already encountered. My system then needs to be able to make an informed decision as to the best decision for the agent to make, and make it. It will then need to store the resulting outcome, be it positive or negative for later use. At the end of the current game, my system should also be able to evaluate performance using some kind of algorithm to measure the comparative efficiency of each learning technique used. A simple way to do this could be to sum up the number of lemmings which were killed in the process, and measure the time taken to complete the level, with the best techniques obviously killing the least lemmings whilst taking the shortest time. A more complex (and more accurate) algorithm could also take into account other variables such as the number of lemmings that reached the exit, the number of tools used etc, or even analyse the performance of individual lemmings.There are a number of issues regarding the functionality and implementation of my system which I will need to address during the design phase. One such issue is whether I will use a separate knowledge-base per lemming, or use a shared knowledge-base for all lemmings. The latter will obviously result in a system which is much more efficient at learning, but is perhaps less realistic. Using a separate knowledge-base per agent would no doubt allow for much more interesting analysis at the end of each game. Something else which I will need to address is how I manage the agents’ interaction with the environment; whether I will carry out automatic checks to update the system, or use an event-based system to notify the AI of any agent interaction. A final question I will need to address is that of user input; exactly how much the user is able to change, and exactly what parameters will be most useful for the user to be able to manipulate during runtime. It may be interesting for example, to be able to adjust the ‘curiosity’ of the lemmings (i.e. the likelihood that they will explore unknown paths/obstacles).In addition to this basic functionality, there are also a number of other features that I would like to implement (time permitting). Firstly, I would like to have two modes in the game: one where the lemming characters respawn at the entrance when they are killed, and one where the lemmings are unable to respawn, and the game ends when all lemmings have been killed. The latter could provide some interesting results, as the user must develop a detailed enough knowledge base with a limited number of agents. Finally, I would also like to implement the ability for agents to learn by ‘watching’ other agents interacting with the environment, in addition to learning from first-hand experience.As a final consideration, my system needs to be able to perform all of the above for multiple agents in real-time, so performance will need to be a serious consideration so as not to affect the gameplay or frame-rate, and my system will need to be appropriately designed with this in mind.Development, Software and FrameworksIn this section, I will briefly discuss the development of my project with regard to the software and frameworks that I intend to use, as well as my reasoning behind them.The first choice I was faced with was the language that I would use to program my system in. As a significant chunk of my is a game, the obvious choice would be to use C++, as it offers the best performance, and has a lot of useful memory management features. In the end though, I made the decision to use Java, despite the fact that generally speaking, it is not the best choice for game programming for performance issues. Although performance is a serious consideration for my project, . The most attractive aspect of Java for me is its cross-platform capability, and its ability to run in-browser. With almost 65% of personal computer users having Java enabled [riastats.com], this could provide invaluable when it comes to the user testing of my program, as I could upload it to a server and easily get users to test it remotely. Doing this would also make my data collection much easier, as the data for each user would be stored in a central location and could easily be accessed without the users needing to submit any data. Java also utilises automatic memory management which, while decreasing the performance of programs, removes many common related bugs such as memory leaks and garbage collection issues. The next big decision I had to make when planning my project was the game engine that I would be using to implement the game component. As I am essentially creating a game for part of my project, I would need to be able to load 3D models and their accompanying textures, animations and bone-structures, have basic lighting, be able to realistically calculate physics, have a user interface, and so on. Implementing all of this myself would require a considerable amount of programming time, time which could be better spent working on my AI engine. Because of this, and the fact that my project has a clear focus on the AI behind the game, it was an obvious decision to use an existing game engine. There are a number of free game engines currently available, some popular examples being Unity, which is available for Windows, Mac OS X, iOS and Android as well as in-browser, Epic Games’ Unreal Engine (used in Unreal Tournament games, as well as for the Gears of War and Bioshock series among others) which is similarly cross-platform and Crytek’s CryEngine (used for the Crysis game franchise). I have decided to use the lesser-known JMonkey engine for my project. First of all, JMonkey supports Java, which many engines don’t (as Java is generally not an ideal language to use to develop a game). In addition, the engines mentioned previously firstly have many advanced features which would be superfluous to my project, but they can also only be used with the supplied software development kit (SDK). What I particularly like about JMonkey is that you can use the SDK if you want, or you can use the engine with any other environment, and simply link to the engine. This was a major selling point for me, as it meant that I didn’t need to learn to use any proprietary SDK, but could use software I was familiar with. JMonkey also includes the popular Bullet physics engine, which is used in many commercial games (such as Rockstar’s Grand Theft Auto IV and Red Dead Redemption). In addition, JMonkey is completely open source, using the New BSD software license, and has an excellent developer community.I will be using a Git server to store the source code for my project. Using source control is critical for any software development project, as it not only provides a way for multiple users to work on a single project without the worry of file corruption, but also provides a way to track the incremental development of a project, with the ability to revert certain changes to an earlier version if need be.Risk AnalysisUt eu faccum nullamet nissi ea feugiat, quisi bla consecte tie exercilit inim dio dolobore magna faccum. Duis autem vel eum iriure dolor inim dio dolobore magna. Dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum  delenit augue duis dolore te feugait nulla.Initial ResearchI have documented my initial research in the form of an annotated bibliography. Along with each source’s basic information, I have included a basic summary and any other notes where appropriate. 	Planning and Research	1	Astronomy 101 Report	5Astronomy 101 Report	5